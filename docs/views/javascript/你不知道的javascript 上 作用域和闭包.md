---
title: 你不知道的javascript(上)作用域和闭包
date: 2020-03-09
tags:
 - 你不知道的javascript
categories:
 -  JavaScript
sidebar: auto
---

## 作用域
**要一套设计良好的规则来存储变量，并且之后可以方便地找到这些变量。 这套规则被称为作用域**
### 编译原理
尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。
在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为`编 译`
1. 分词/词法分析（Tokenizing/Lexing）
将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代 码块被称为`词法单元`（token  
`var a = 2;`   。这段程序通常会被分解成 为下面这些词法单元：`var、a、=、2 、;`
2. 解析/语法分析（Parsing）
将词法单元转换成`抽象语法树AST`
![](https://resource.limeili.top/image/20200316150331.png)
3. 代码生成
简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指 令，用来创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中

* 对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时 间内

### 理解作用域
* `引擎`从头到尾负责整个 JavaScript 程序的编译及执行过程
* `编译器`负责语法分析及代码生成等脏活累活
* `作用域`负责收集并维护由所有声明的标识符（变量）组成的一系列查 询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限

`var a = 2`事实上编译器会进行如下处理
1. 遇到 var a，**编译器**会询问**作用域**是否已经有一个该名称的变量存在于同一个作用域的 集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作 用域的集合中声明一个新的变量，并命名为 a
2. 接下来**编译器**会为**引擎**生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值 操作。**引擎**运行时会首先询问**作用域**，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量
如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异 常！

### RHS和LHS
当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询（更准确的说是非左侧）
LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“= 赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最 好将其理解为  
`“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头(得到某某的值) （RHS）`
```js
function foo(a) { console.log( a ); // 2 }
foo( 2 )
```
* 最后一行 foo(..) 函数的调用需要对 foo 进行 `RHS` 引用，意味着“去找到 foo 的值，并把 它给我”,并且 (..) 意味着 foo 的值需要被执行，因此它最好真的是一个函数类型的值
* 代码中隐式的 a＝2 操作可能很容易被你忽略掉。这个操作发生在 2 被当作参数传递给 foo(..) 函数时，2 会被分配给参数 a。为了给参数 a（隐式地）分配值，需要进行一次 `LHS` 查询。
* 里还有对 a 进行的 `RHS` 引用，并且将得到的值传给了 console.log(..)
* 会对 console 对象进行 `RHS `查询，并且检查 得到的值中是否有一个叫作 log 的方法

### 作用域嵌套
引擎从当前的执行作用域开始查找变量，如果找不到， 就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都 会停

### 异常
```js
function foo(a) { console.log( a + b ); b = a; }
foo( 2 )
```
* 第一次对 b 进行 RHS 查询时是无法找到该变量的。也就是说，这是一个“未声明”的变 量，因为在任何相关的作用域中都无法找到它,引擎就会抛出 `ReferenceError `异常
* 当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量， 全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式”下
* 严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 `ReferenceError `异常。
* 如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的 属性，那么引擎会抛出另外一种类型的异常，叫作 `TypeError`
ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对 结果的操作是非法或不合理的。

## 词法作用域
作用域有两种工作模型，一种是最为普遍的被大多数编程语言所采用的词法作用域,另一种是动态作用域

### 词法阶段

词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写 代码时将变量和块作用域写在哪里来决定的
* 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的 标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应， 作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见 第一个匹配的标识符为止。
* 词法作用域查找只会查找一级标识符，比如 a、b 和 c。如果代码中引用了 foo.bar.baz， 词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接 管对 bar 和 baz 属性的访问。

### 欺骗词法
1. eval
```js
function foo(str, a) { 
  eval( str ); // 欺骗！ 
  console.log( a, b ); 
  }
var b = 2; 
foo( "var b = 3;", 1 ); // 1, 3
```
eval(..) 调用中的 "var b = 3;" 这段代码会被当作本来就在那里一样来处理。由于那段代 码声明了一个新的变量 b，因此它对已经存在的 foo(..) 的词法作用域进行了修改。事实 上，和前面提到的原理一样，这段代码实际上在 foo(..) 内部创建了一个变量 b，并遮蔽 了外部（全局）作用域中的同名变量。

2. with()
with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象 本身
```js
var obj = { a: 1, b: 2, c: 3 };
// 单调乏味的重复 "obj" 
obj.a = 2; obj.b = 3; obj.c = 4; 
// 简单的快捷方式
with (obj) { a = 3; b = 4; c = 5; }
```
```js
function foo(obj) {
with (obj) { a = 2; } }
var o1 = { a: 3 }
var o2 = { b: 3 };
foo( o1 ); console.log( o1.a ); // 2
foo( o2 ); console.log( o2.a ); // undefined
console.log( a ); // 2——不好，a 被泄漏到全局作用域上了！
```
with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对 象的属性也会被处理为定义在这个作用域中的词法标识符。
**eval(..) 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而 with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。**
可以这样理解，当我们传递 o1 给 with 时，with 所声明的作用域是 o1，而这个作用域中含 有一个同 o1.a 属性相符的标识符。但当我们将 o2 作为作用域时，其中并没有 a 标识符， 因此进行了正常的 LHS 标识符查找（查看第 1 章）。 o2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此当 a＝2 执行 时，自动创建了一个全局变量（因为是非严格模式）。  


编译的词法分析阶段 基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它 们进行查找。  但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断 都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会 如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底 是什么  

这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认 为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们

## 函数作用域和块作用域
在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐 藏”起来，外部作用域无法访问包装函数内部的任何内容。
```js
var a = 2;
function foo() { // <-- 添加这一行
  var a = 3; 
  console.log( a ); // 3 
} // <-- 以及这一行 
foo(); // <-- 以及这一行 
console.log( a ); // 2
```
虽然这种技术可以解决一些问题，但是它并不理想，因为会导致一些额外的问题。
1. 首先， 必须声明一个具名函数 foo()，意味着 foo 这个名称本身“污染”了所在作用域（在这个 例子中是全局作用域）。
2. 其次，必须显式地通过函数名（foo()）调用这个函数才能运行其 中的代码。
`解决办法`
```js
(function foo(){ // <-- 添加这一行
  var a = 3; 
  console.log( a ); // 3 
})();
```

**区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位 置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式。**
函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。 比较一下前面两个代码片段。第一个片段中 foo 被绑定在所在作用域中，可以直接通过 foo() 来调用它。  
第二个片段中 foo 被绑定在函数表达式自身的函数中而不是所在作用域中。 换句话说，(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中 被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作 用域。



### 匿名和具名
```js
setTimeout( function() { console.log("I waited 1 second!"); }, 1000 );
```
这叫作`匿名函数表达式`，因为 function().. 没有名称标识符。函数表达式可以是匿名的， 而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的
1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难
2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑 自身。
3. 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让 代码不言自明。

### 立即执行函数表达式 IIFE
传统形式`如 (function foo(){ .. })()`
改进形式`(function(){ .. }())`
**IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去**
```js
var a = 2; 
(function IIFE( global ) {
var a = 3; 
console.log( a ); // 3 
console.log( global.a ); // 2 
})( window ); 
console.log( a ); // 2

```
我们将 `window` 对象的引用传递进去，但将参数命名为 `global`

### 块作用域
1. with
块作用域的一种形式，用 with 从对象中创建出的作用域仅在 with 声明中而非外 部作用域中有效
2. try/catch
catch 分句会创建一个块作 用域，其中声明的变量仅在 catch 内部有效
```js
try {
undefined(); // 执行一个非法操作来强制制造一个异常 
}
catch (err) { console.log( err ); // 能够正常执行！ 
}
console.log( err ); // ReferenceError: err not found
```
3. let 
4. const

## 提升
* `函数声明`和`变量声明`都会被提升
* 函数会首先被提升，然后才是变量
* 后面的函数声明可以覆盖前面的
* 一个普通块内部的函数声明通常会被提升到所在作用域的顶部  
`变量提升的原因`
:point_right: [点击这里](../javascript/理解Javascript执行上下文和执行栈.md) :point_left:

```js
foo(); // "b"
var a = true;
if (a) {
function foo() { console.log("a"); } }
else {
function foo() { console.log("b"); } }
```

## 作用域和闭包
闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意 识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿 来识别、拥抱和影响闭包的思维环境

**当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用 域之外执行**
`js高级的解释是`有权访问另一个函数作用域中的变量的函数
`js权威的解释是`从技术角度上讲，所有js函数都是闭包，他们都是对象，都关联到作用域链

```js
function foo() {
  var a = 2;
  function bar() { console.log( a );} // 2 
  bar(); 
}
foo()
```
这是闭包吗？ 技术上来讲，也许是。但根据前面的定义，确切地说并不是。我认为最准确地用来解释 bar() 对 a 的引用的方法是`词法作用域的查找规则`，(RHS)而这些规则只是闭包的一部分  
从纯学术上讲，函数 bar() 具有一个涵盖 foo() 作用域的闭包 （事实上，涵盖了它能访问的所有作用域，比如全局作用域）。也可以认为 bar() 被封闭在 了 foo() 的作用域中。为什么呢？原因简单明了，因为 bar() 嵌套在 foo() 内部。

```js
function foo() {
  var a = 2;
  function bar() { 
    console.log( a ); 
  }
  return bar; 
}
var baz = foo(); 
baz(); // 2
```
1. 函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作 一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值
2. foo() 执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz()，实 际上只是通过不同的标识符引用调用了内部的函数 bar()
3. bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方 执行

::: tip
在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃 圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很 自然地会考虑对其进行回收。   
而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此 没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使  

* 拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一 直存活，以供 bar() 在之后任何时间进行引用。   
* **bar() 依然持有对该作用域的引用，而这个引用就叫作闭包**
:::

**无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用 域的引用，无论在何处执行这个函数都会使用闭包。**
```js
function foo() {
  var a = 2;
  function baz() { 
    console.log( a ); // 2 
  }
  bar( baz ); 
}
function bar(fn) { 
  fn(); // 妈妈快看呀，这就是闭包！ 
}
```
**定时器闭包案例**
```js
function wait(message) { 
  setTimeout( function timer() { 
    console.log( message ); 
    }, 1000 ); 
}
wait( "Hello, closure!" );
```
* 将一个内部函数（名为 timer）传递给 setTimeout(..)。timer 具有涵盖 wait(..) 作用域 的闭包，因此还保有对变量 message 的引用
* 深入到引擎的内部原理中，内置的工具函数 setTimeout(..) 持有对一个参数的引用，这个 参数也许叫作 fn 或者 func，或者其他类似的名字。引擎会调用这个函数，在例子中就是 内部的 timer 函数，而词法作用域在这个过程中保持完整。

**在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使 用了回调函数，实际上就是在使用闭包！**

**事件监听闭包案例**
```js
function setupBot(name, selector) {
    $(selector).click( function activator() {
        console.log( "Activating: " + name );
    });
}
setupBot( "Closure Bot 1", "#bot_1" );
setupBot( "Closure Bot 2", "#bot_2" );
```
### IIFE和闭包
通常认为 IIFE 是典型的闭包例子，但根据先前对 闭包的定义，我并不是很同意这个观点
```js
var a = 2; 
(function IIFE() { 
  console.log( a ); 
})();
```
1. 虽然这段代码可以正常工作，但严格来讲它并不是闭包。为什么？因为函数（示例代码中 的 IIFE）并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行（而 外部作用域，也就是全局作用域也持有 a）。a 是通过普通的词法作用域查找而非闭包被发 现的  
2. 尽管 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建 可以被封闭起来的闭包的工具。因此 IIFE 的确同闭包息息相关，即使本身并不会真的使用 闭包。

### 循环和闭包
```js
for (var i=1; i<=5; i++) { 
    setTimeout( function timer() { 
      console.log( i ); 
    }, i*1000 ); 
}
```
**延迟函数的回调会在循环结束时才执行**。事实上， 当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0)，所有的回调函数依然是在循 环结束后才会被执行，因此会每次输出一个 6 出来。  
缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。但是 根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的， 但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。  

`我们需要更多的闭包作用域，特别是在循环的过程中每个迭 代都需要一个闭包作用域`

```js
for (var i=1; i<=5; i++) { (function() {
var j = i; setTimeout( function timer() { console.log( j ); }, j*1000 ); })(); }
```
```js
for (var i=1; i<=5; i++) { (function(j) { setTimeout( function timer() { console.log( j ); }, j*1000 ); })( i ); }
```
在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的 作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问

### 模块
```js
function CoolModule() {
  var something = "cool";
  var another = [1, 2, 3];
  function doSomething() { 
    console.log( something );
  }
  function doAnother() {
    console.log( another.join( " ! " ) );
  }
  return {
      doSomething: doSomething, 
      doAnother: doAnother
  };
}

var foo = CoolModule(); 
foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```
这个模式在 JavaScript 中被称为模块。  
这个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐 藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的公共 API
**模块模式具备两个必要的条件**
* 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块 实例）。
* 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并 且可以访问或者修改私有的状态。

**单例模式**
```js
var foo = (function CoolModule() { 
  var something = "cool";
  var another = [1, 2, 3];
   function doSomething() { 
      console.log( something );
  }
  function doAnother() {
    console.log( another.join( " ! " ) );
  }
  return {
      doSomething: doSomething, 
      doAnother: doAnother
  }; 
})();
foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```
**现代模块**
　大多数模块依赖加载器本质上都是将这种模块定义封装进一个友好的API。
```js
 var module = (function() {
        //将模块API储存在一个根据名字管理的模块列表中
        var modules = {};
        //三个参数分别为模块名、依赖项、模块内容
        function define(name, deps, impl) {
            for (var i = 0; i < deps.length; i++) {
                //取出模块 替换掉模块名字符串
                deps[i] = modules[deps[i]];
            }
            //核心代码
            //为了模块的定义引入了包装函数
            //注入模块
            modules[name] = impl.apply(impl, deps);
        }

        function get(name) {
            return modules[name];
        }
        return {
            define: define,
            get: get
        };
    })();
    //modules={bar:{hello:hello}}
    module.define('bar', [], function() {
        function hello(who) {
            return 'let me introduce ' + who;
        }
        return {
            hello: hello
        };
    });

    module.define('foo', ['bar'], function() {
        var hungry = 'hippo';

        function awesome() {
            console.log(bar.hello(hungry).toUpperCase());
        }
        return {
            awesome: awesome
        };
    });
    var bar = module.get('bar');
    var foo = module.get('foo');
    console.log(bar.hello('hippo')); //let me introduce hippo
    foo.awesome(); //LET ME INTRODUCE HIPPO
```
