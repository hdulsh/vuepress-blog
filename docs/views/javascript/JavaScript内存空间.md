---
title: JavaScript内存空间
date: 2020-03-09
tags:
 - 
categories:
 -  JavaScript
sidebar: auto
---
![](https://resource.limeili.co/abstract/abstract%20(11).jpg)
<!-- more -->
## 栈数据结构
栈的结构就是`后进先出`**（LIFO）**，

## 堆数据结构
堆数据结构是一种树状结构。它的存取数据的方式与书架和书非常相似。我们只需要知道书的名字就可以直接取出书了，并不需要把上面的书取出来。JSON格式的数据中，我们存储的key-value可以是无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字


## 队列
队列是一种`先进先出`**（FIFO）**的数据结构，这是事件循环（Event Loop）的基础结构
![](https://resource.limeili.co/image/202003231514.jpg)

## 变量的存放
1. 基本类型 --> 保存在栈内存中，因为这些类型在内存中分别占有固定大小的空间，通过按值来访问。基本类型一共有6种：Undefined、Null、Boolean、Number 、String和Symbol
2. 引用类型 --> 保存在堆内存中，因为这种值的大小不固定，因此不能把它们保存到栈内存中，但内存地址大小的固定的，因此保存在堆内存中，在栈内存中存放的只是该对象的访问地址。当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问

:::tip
在计算机的数据结构中，栈比堆的运算速度快，Object是一个复杂的结构且可以扩展：数组可扩充，对象可添加属性，都可以增删改查。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。所以查找引用类型值的时候先去栈查找再去堆查找
:::


## 内存空间管理
1. 分配你所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放、归还
JavaScript有自动垃圾收集机制，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，使用a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。

在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在开发中，需要尽量避免使用全局变量

## 内存回收
局部变量和全局变量的销毁
* 局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。
* 全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。

以Google的V8引擎为例，V8引擎中所有的JS对象都是通过堆来进行内存分配的
* 初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。
* 继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。

V8引擎对堆内存中的JS对象进行分代管理
* 新生代：存活周期较短的JS对象，如临时变量、字符串等。
* 老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。
#垃圾回收算法

## 垃圾回收算法
* 引用计数（现代浏览器不再使用）
* 标记清除（常用）

### 引用计数
引用计数算法定义“内存不再使用”的标准很简单，就是看`一个对象是否有指向它的引用`。如果没有其他对象指向它了，说明该对象已经不再需要了。
```js
// 创建一个对象person，他有两个指向属性age和name的引用
var person = {
    age: 12,
    name: 'aaaa'
};

person.name = null; // 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收

var p = person; 
person = 1;         //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收

p = null;           //原person对象已经没有引用，很快会被回收
```
如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。
```js
var div = document.createElement("div");
div.onclick = function() {
    console.log("click");
};

```
上面的写法很常见，但是上面的例子就是一个循环引用。

变量div有事件处理函数的引用，同时事件处理函数也有div的引用，因为div变量可在函数内被访问，所以循环引用就出现了

### 标记清除
标记清除算法将“不再使用的对象”定义为“`无法到达的对象`”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。

无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。

所以上面的例子就可以正确被垃圾回收处理了。

所以现在对于主流浏览器来说，只需要切断需要回收的对象与根部的联系。最常见的内存泄露一般都与DOM元素绑定有关：
```js
email.message = document.createElement(“div”);
displayList.appendChild(email.message);

// 稍后从displayList中清除DOM元素
displayList.removeAllChildren();
```
上面代码中，div元素已经从DOM树中清除，但是该div元素还绑定在email对象中，所以如果email对象存在，那么该div元素就会一直保存在内存中

## 内存泄漏
对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak

