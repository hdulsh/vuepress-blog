---
title: 原型和原型链的底层运行机制
date: 2020-03-09
tags:
 - 原型链
categories:
 -  JavaScript
sidebar: auto
---

![](https://resource.limeili.co/abstract/abstract%20(28).jpg)
<!-- more -->

# 原型prototype和原型链__proto__
1. 每一个类（函数）都具备prototype，并且属性值是一个对象

2. prototype天生具备一个属性：constructor，指向类本身

3. 每一个对象（普通对象、prototype、实例、函数等）都具备：__proto__，属性值是当前实例所属类的原型
```js
function Fn() {
    this.x = 100;
    this.y = 200;
    this.getX = function () {
        console.log(this.x);
    }
}
Fn.prototype.getX = function () {
    console.log(this.x);
};
Fn.prototype.getY = function () {
    console.log(this.y);
};
let f1 = new Fn;
let f2 = new Fn;
console.log(f1.getX === f2.getX);//false
console.log(f1.getY === f2.getY);//true
console.log(f1.__proto__.getY === Fn.prototype.getY);//true
console.log(f1.__proto__.getX === f2.getX);//false
console.log(f1.getX === Fn.prototype.getX);//false
console.log(f1.constructor);//Fn
console.log(Fn.prototype.__proto__.constructor);//Object
f1.getX();//100
f1.__proto__.getX();//undefined
f2.getY();//200
Fn.prototype.getY();//undefined
```
![](https://resource.limeili.co/image/202005211724.png)

# 内置Array的图
![](https://resource.limeili.co/image/202005212307.png)

# 编写plus和minus
```js
~ function anonymous(proto) { //anonymous匿名函数放在闭包里实现私有化
	const checkNum = function checkNum(num) {
		num = Number(num);
		if (isNaN(num)) {
			num = 0;
		}
		return num;
	};
	proto.plus = function plus(num) {
		//=>this:我们要操作的那个数字实例（对象）
		//=>返回Number类的实例，实现链式写法
		return this + checkNum(num);// Number{10}有个[[PrimitiveVakue]]:10  计算时先调用的valueOf()
	};
	proto.minus = function minus(num) {
		return this - checkNum(num);
	};
}(Number.prototype);

```