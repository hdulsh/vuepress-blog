---
title: 笔记2
date: 2020-03-09
tags:
 - 
categories:
 - 
---

## 作用域
你不知道JS:要一套设计良好的规则来存储变量，并且之后可以方便地找到这些变量。 这套规则被称为作用域  

用域有两种工作模型，一种是最为普遍的被大多数编程语言所采用的词法作用域,另一种是动态作用域  

词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写 代码时将变量和块作用域写在哪里来决定的  
我的理解是  

在某一个执行上下文中创建函数，除了开辟堆内存和赋值之外，还会给当前函数设置一个作用域属性[[scope]] ：这个属性就等于`当前函数创建时候所在的上下文 `    


也就是说，当前函数的作用域取决于当前函数创建时候的上下文，它在哪个上下文创建的，那它的作用域就是谁

作用域分为全局作用域、函数作用域和块作用域  


## 作用域链
:::tip
全局变量：在全局上下文EC(G)中的全局变量对象VO(G)中，存储的变量  

私有变量：在函数执行形成的私有上下文EC(XXX)中的变量对象AO(XXX)中，存储的变量  
都有哪些是私有变量呢：

* 当前函数执行形成的上下文中：声明过的变量或者函数，都会存储到AO(XXX)中，
* 函数定义的形参变量，也会存储到当前上下文的AO(XXX)中
:::




在当前上下文中，代码执行的过程中遇到一个变量时：  
首先看它是否是私有的  
* 如果是私有的，接下来的所有操作，都是操作自己的，和别人没有关系；
* 如果不是就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。  如果找到EC(G)都找不到，是获取变量值就会报错，是设置值，相当于给GO加属性
**这样由多个执行上下文的变量对象构成的链表就叫做作用域链。**  



函数创建 函数的作用域在函数定义的时候就决定了。  


这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！  
函数激活 当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。
这时候执行上下文的作用域链，我们命名为 Scope： Scope = [AO].concat([[Scope]]); 至此，作用域链创建完毕

`作用域链是在函数执行的时候形成的；执行函数的具体步骤为：`  
* 创建私有上下文EC（有存放私有变量的变量对象AO）
* 进栈执行（时会把全局上下文压缩到底部）
* 初始化作用域链 scopeChain:<当前EC，函数[[scope]]>
* 初始化THIS指向
* 形参赋值（包含初始化ARGUMENTS）
* 变量提升
* ......这里我们省略了一些
* 代码执行
* 执行完可能会出栈（也可能不出栈）

许多开发人员经常混淆作用域和执行上下文的概念，误认为它们是相同的概念，但事实并非如此。  
javaScript 解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是 this 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。  
**执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变**  
一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。  




## 执行上下文  
执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。  

* 全局执行上下文
* 函数执行上下文

为了能够让代码执行，浏览器首先会形成一个执行环境栈ECStack，有了栈内存代码就可以自上而下的执行了，开始执行全局下的代码，就会形成一个全局执行上下文EC(G)，形成之后，把EC(G)压缩到栈内存中去执行（进栈），每当发生一个函数`调用`，引擎都会为该函数创建一个新的执行上下文并将其推到当前执行栈的顶端。 引擎会运行执行上下文在执行栈顶端的函数，当此函数运行完成后，其对应的执行上下文将会从执行栈中弹出，上下文控制权将移到当前执行栈的下一个执行上下文。  

`ES3和ES5执行上下文创建的差异`  

#ES3
* 创建作用域链。
* 创建变量对象VO(包括参数，函数，变量)。
* 确定this的值  

#ES5
* 确定 this 的值。
* 创建词法环境(LexicalEnvironment)
* 创建变量环境(VariableEnvironment)
ES3的VO，AO为什么可以被抛弃？个人认为有两个原因，第一个是在创建过程中所执行的创建作用域链和创建变量对象(VO)都可以在创建词法环境的过程中完成。第二个是针对es6中存储函数声明和变量(let 和 const)以及存储变量(var)的绑定，可以通过两个不同的过程(词法环境，变量环境)区分开来。   


`创建变量对象VO`
执行上下文的代码会分成两个阶段进行处理  
1. 进入执行上下文

很明显，这个时候还没有执行代码，此时的变量对象会包括（如下顺序初始化）:

* 函数的所有形参 (只有在函数上下文)：没有实参，属性值设为undefined。
* 函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。
* 变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。
```js
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;
}

foo(1);


AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}



```

2. 代码执行   
这个阶段会顺序执行代码，修改变量对象的值，执行完成后AO如下
```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}
```

` 作用域链`
以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的  

**创建阶段**  
`词法环境  `
1. 环境记录:存储变量和函数声明的实际位置

2. 对外部环境的引用：可以访问其外部词法环境  



` 变量环境`
  

也是一个词法环境,区别在于前者用于存储函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）绑定  

在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升 