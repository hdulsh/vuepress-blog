---
title: 笔记2
date: 2020-03-09
tags:
 - 
categories:
 - 
---

## 作用域
你不知道JS:要一套设计良好的规则来存储变量，并且之后可以方便地找到这些变量。 这套规则被称为作用域  

用域有两种工作模型，一种是最为普遍的被大多数编程语言所采用的词法作用域,另一种是动态作用域  

词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写 代码时将变量和块作用域写在哪里来决定的  
我的理解是  

在某一个执行上下文中创建函数，除了开辟堆内存和赋值之外，还会给当前函数设置一个作用域属性[[scope]] ：这个属性就等于`当前函数创建时候所在的上下文 `    


也就是说，当前函数的作用域取决于当前函数创建时候的上下文，它在哪个上下文创建的，那它的作用域就是谁

作用域分为全局作用域、函数作用域和块作用域  


## 作用域链
:::tip
全局变量：在全局上下文EC(G)中的全局变量对象VO(G)中，存储的变量  

私有变量：在函数执行形成的私有上下文EC(XXX)中的变量对象AO(XXX)中，存储的变量  
都有哪些是私有变量呢：

* 当前函数执行形成的上下文中：声明过的变量或者函数，都会存储到AO(XXX)中，
* 函数定义的形参变量，也会存储到当前上下文的AO(XXX)中
:::




在当前上下文中，代码执行的过程中遇到一个变量时：  
首先看它是否是私有的  
* 如果是私有的，接下来的所有操作，都是操作自己的，和别人没有关系；
* 如果不是就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。  如果找到EC(G)都找不到，是获取变量值就会报错，是设置值，相当于给GO加属性
**这样由多个执行上下文的变量对象构成的链表就叫做作用域链。**  



函数创建 函数的作用域在函数定义的时候就决定了。  


这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！  
函数激活 当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。
这时候执行上下文的作用域链，我们命名为 Scope： Scope = [AO].concat([[Scope]]); 至此，作用域链创建完毕

`作用域链是在函数执行的时候形成的；执行函数的具体步骤为：`  
* 创建私有上下文EC（有存放私有变量的变量对象AO）
* 进栈执行（时会把全局上下文压缩到底部）
* 初始化作用域链 scopeChain:<当前EC，函数[[scope]]>
* 初始化THIS指向
* 形参赋值（包含初始化ARGUMENTS）
* 变量提升
* ......这里我们省略了一些
* 代码执行
* 执行完可能会出栈（也可能不出栈）

许多开发人员经常混淆作用域和执行上下文的概念，误认为它们是相同的概念，但事实并非如此。  
javaScript 解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是 this 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。  
**执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变**  
一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。  




## 执行上下文  
执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。  

* 全局执行上下文
* 函数执行上下文

为了能够让代码执行，浏览器首先会形成一个执行环境栈ECStack，有了栈内存代码就可以自上而下的执行了，开始执行全局下的代码，就会形成一个全局执行上下文EC(G)，形成之后，把EC(G)压缩到栈内存中去执行（进栈），每当发生一个函数`调用`，引擎都会为该函数创建一个新的执行上下文并将其推到当前执行栈的顶端。 引擎会运行执行上下文在执行栈顶端的函数，当此函数运行完成后，其对应的执行上下文将会从执行栈中弹出，上下文控制权将移到当前执行栈的下一个执行上下文。  

`ES3和ES5执行上下文创建的差异`  

#ES3
* 创建作用域链。
* 创建变量对象VO(包括参数，函数，变量)。
* 确定this的值  

#ES5
* 确定 this 的值。
* 创建词法环境(LexicalEnvironment)
* 创建变量环境(VariableEnvironment)
ES3的VO，AO为什么可以被抛弃？个人认为有两个原因，第一个是在创建过程中所执行的创建作用域链和创建变量对象(VO)都可以在创建词法环境的过程中完成。第二个是针对es6中存储函数声明和变量(let 和 const)以及存储变量(var)的绑定，可以通过两个不同的过程(词法环境，变量环境)区分开来。   


`创建变量对象VO`
执行上下文的代码会分成两个阶段进行处理  
1. 进入执行上下文

很明显，这个时候还没有执行代码，此时的变量对象会包括（如下顺序初始化）:

* 函数的所有形参 (只有在函数上下文)：没有实参，属性值设为undefined。
* 函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。
* 变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。
```js
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;
}

foo(1);


AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}



```

2. 代码执行   
这个阶段会顺序执行代码，修改变量对象的值，执行完成后AO如下
```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}
```

` 作用域链`
以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的  

**创建阶段**  
`词法环境  `
1. 环境记录:存储变量和函数声明的实际位置

2. 对外部环境的引用：可以访问其外部词法环境  



` 变量环境`
  

也是一个词法环境,区别在于前者用于存储函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）绑定  

在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升 


## 变量提升
从浏览器的运行机制说起  ...创建执行上下文（1.进入 2.执行）...作用域链 形参赋值  this  变量提升...代码执行  

找些代码来调用一个函数
1. 在执行函数代码之前，创建执行上下文。
2. 进入创建阶段


    + 初始化作用域链
    + 创建变量对象：

        * 创建arguments对象，检查参数的上下文，初始化名称和值并创建引用的副本。
        * 扫描上下文以获取函数声明：对于找到的每个函数，在变量对象（或活动对象）中创建一个属性，该属性是确切的函数名称，该函数具有指向内存中函数的引用指针。**如果函数名已存在，则将覆盖引用指针值**。


        * 扫面上下文以获取变量声明：对于找到的每个变量声明，在变量对象（或活动对象）中创建一个属性，该属性是变量名称，并将值初始化为undefined。**如果变量名称已存在于变量对象（或活动对象）中，则不执行任何操作并继续扫描（即跳过）。**


    + 确定上下文中的this。
3. 执行阶段





  

就是在当前上下文中，JS代码执行之前要做的事情；首先会默认把所有带VAR和FUNCTION关键字的进行声明或者定义。

* 带VAR的只是提前声明
* 带FUNCTION的会提前声明+定义    

**推荐使用函数表达式方式创建函数**  


`变量提升在条件判断下的处理`  

1. 全局上下文中带VAR的  

不论IF条件是否成立都进行（只要不在函数里面，带VAR的都要变量提升）
无论是IF还是FOR中的VAR都进行提升；

2. 全局上下文中带FUNCTION的  
* [IE 10及以前以及谷歌等浏览器低版本状态下]：function func(){ ... } 声明+定义都处理了  

* [最新版本的浏览器中，机制变了]：function func; 用判断或者循环等包裹起来的函数，在变量提升阶段，不论条件是否成立，只会先声明  
```js
console.log(func); //=>undefined
if (1 === 1) {
	// 此时条件成立，进来的第一件事情还是先把函数定义了（迎合ES6中的块作用域） => func=function(){ .... }
	console.log(func); //=>函数
	function func() {
		console.log('OK');
	}
	console.log(func); //=>函数
}
console.log(func); //=>函数

```


## 闭包  

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用 域之外执行   
js高级的解释是有权访问另一个函数作用域中的变量的函数   
js权威的解释是从技术角度上讲，所有js函数都是闭包，他们都是对象，都关联到作用域链

函数执行形成的一个不销毁的私有上下文，即能保护里面的私有变量不受外界干扰，也能在当前上下文中保存一些信息（前提：形成的上下文不销毁），上下文中的这种保存和保护机制，就是闭包机制  
浏览器加载页面会把代码放到栈内存（ECStack）中执行，函数进栈执行会产生一个私有的上下文（EC），此上下文能保护里面的私有变量（AO），不受外界干扰，并且如果当前上下文中的某些内容（一般是一个堆），被上下文以外的内容所占用，当前上下文是不会出站释放，这样可以保存里面的变量和变量值，所以我认为闭包是一种保护和保存内部变量的机制

我会基于闭包把自己编写的模块内容包起来，这样自己编写的代码都是私有的，防止和全局变量或别人的代码冲突，这一点利用的是闭包的保护机制  

在没有ES6的LET之前，我们循环处理事件绑定，在事件触发需要用到索引值的时候，我们基于闭包，把每一轮循环的索引值保存起来，这样来实现我们的需求，只不过现在都是基于LET来完成，因为LET会产生块级作用域来保存需要的内容（机制和闭包类似）  

但是不建议过多使用闭包，因为形成的不被释放的上下文，是占用栈内存空间的，过多使用会导致页面渲染变慢，所以要合理应用闭包；  

除了这些传统的业务开发中会用到闭包，我之前在研究别人源码和自己写一写插件的时候，往往会利用一些JS高阶编程技巧来实现代码的管理和功能的开发，他们的底层机制其实就是闭包，例如：

惰性函数
柯理化函数
compose函数




1. 堆栈内存及垃圾回收机制  
**查找引用方式** 
浏览器有自动回收垃圾的机制，定期间隔某段时间，把所有没有被占用的内存回收释放（这种垃圾回收机制，比其它语言要完善一些）  

堆内存释放：如果当前创建的堆内存不被其它东西所占用了（浏览器会在空闲的时候，查找每一个内存的引用状况，不被占用的都会给回收释放掉），则会释放，，我们想去手动释放它，则取消所有的占用：赋值为NULL  
栈内存释放：全局栈内存：关掉页面的时候才会销毁  
私有栈内存：
一般情况下，函数只要执行完成，形成的私有栈内存就会被销毁释放掉  

.但是一旦栈内存中的某个东西（一般都是堆地址）被私有作用域以外的事物给占用了，则当前私有栈内存不能立即被释放销毁（特点：私有作用域中的私有变量等信息也保留下来了=>这种函数执行形成不能被释放的私有栈内存，也叫做闭包）  

2. AO、VO ESStack SCOPECHANIN    

3. 闭包的作用：保护和保存  
`保护`  
* 团队协作开发中;
A/B共同开发一个页面，最后要把代码合并在一起，为了防止全局变量的冲突污染，我们建议每个开发者，都把自己的代码放置到一个闭包中（自执行函数执行即可，这样就是私有的上下文）保护起来  
* 封装一个插件或者类库等;
为了防止我们定义的变量和方法 和 用户定义的冲突，我们也是需要把所有写的代码放到一个闭包中，例如：jQuery  
```js
 (function(){
     function jQuery(){
         ...
     }
     ...
     window.jQuery = window.$ = jQuery
     //把需要供外面使用的方法，通过给window设置属性的方式暴露出去
 })()
 jQuery()
 $()


 var Zepto = (function(){
    //...
    return {
        xxx:function(){}
    }
})()
Zepto.xxx()

//单例设计模式 基于return把需要供外面使用的方法暴露出去
```
  
`保存`    
形成不销毁的栈内存，把一些值保存下来。方便后面的调取使用    
惰性函数、柯理化函数(bind)、compose函数等JS高阶编程技巧中，就是基于闭包的保存机制实现的）   


防抖和节流  
函数节流：一个函数执行一次后，只有大于设定的执行周期后才会执行第二次。 有个需要频繁触发函数，出于优化性能角度，在规定时间内，只让函数触发的第一次生效，后面不生效  

```js
function throttle(fn, delay) {
    // 记录上一次函数触发的时间
    var lastTime = 0;
    return function() {
        // 记录当前函数触发的时间
        var nowTime = Date.now();
        if (nowTime - lastTime > delay) {
        // 修正this指向问题
            fn.call(this);
        // 同步时间
          lastTime = nowTime;
        }
    }
}
```
防抖函数：一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效 
```js
function debounce(fn, delay) {
    // 记录上一次的延时器
   var timer = null;
    return function() {
    // 清除上一次延时器
    clearTimeout(timer)
    timer = setTimeout(function() {
            fn.apply(this)
        }, delay)
    }
}
```


因为闭包会产生不销毁的上下文，这样导致栈/堆内存消耗过大，有时候也会导致内存泄漏等，影响页面的运行性能，所以在真实项目中，要合理应用闭包（不要滥用）  



## 原型原型链继承
[1](../javascript/原型和原型链的底层运行机制.md)  

[2](../javascript/new的实现原理.md)
  
[3](../javascript/JS中的四大继承方案.md)


## this  call apply bind
## 事件队列和事件循环机制


## 性能优化 
1. 减少HTTP请求的次数和大小  
2. 建立缓存机制  
DNS预获取
资源文件的强缓存和协商缓存（304）
数据也可以做缓存（把从服务器获取的数据存储到本地：cookie/localStorage/redux/vuex等，设定期限，在期限内，直接从本地获取数据即可）
离线存储（一般很少用）manifest
CDN区域分布式服务器开发部署（费钱 效果会非常的好）  
3. 代码上的优化  
减少DOM的重绘和回流
在JS中尽量减少闭包的使用（内存优化）
在JS中避免“嵌套循环”和“死循环”
尽可能使用事件委托
尽量减少CSS表达式的使用(expression)
CSS选择器解析规则是从右向左解析（基于less/sass开发的时候尽可能减少层级嵌套，目的是让选择器的前缀短一点） 【 a{} 和 .box a{}】
尽可能实现JS的封装（低耦合高内聚），减少页面中的冗余代码
在CSS导入的时候尽量减少使用@import导入式
使用window.requestAnimationFrame（JS中的帧动画）代替传统的定时器动画（能用CSS3动画的绝对不用JS动画）
减少递归的使用，避免死递归，避免由于递归导致的栈内存嵌套
基于SCRIPT调取JS的时候，可已使用 defer或者async 来异步加  

4. 安全
5. webpack  