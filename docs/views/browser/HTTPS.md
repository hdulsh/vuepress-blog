---
title: HTTPS
date: 2020-03-09
tags:
 - HTTPS
categories:
 -  Browser
sidebar: auto
---

![](https://resource.limeili.co/abstract/abstract%20(48).jpg)
<!-- more -->

## HTTP缺点
1. 通信使用明文（不加密），内容可能被窃听  
由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（使用HTTP协议通信的请求和响应的内容）进行加密。即，HTTP报文使用明文（指未经过加密的报文）方式发送。
HTTP明文协议的缺陷是导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题的重要原因。HTTP协议无法加密数据，所有通信数据都在网络中明文“裸奔”。通过网络的嗅探设备及一些技术手段，就可还原HTTP报文内容。

2. 无法证明报文的完整性，所以可能遭篡改  

没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的  

3. 不验证通信方的身份，因此有可能遭遇伪装

## HTTPS解决上述缺点
HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。
通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。  

HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：
1. 散列函数 ，验证信息的完整性
2. 对称加密，采用协商的密钥对数据加密
3. 非对称加密，其利用非对称加密实现身份认证和密钥协商

![](https://resource.limeili.co/image/202007042222.png)
### 1.解决内容可能被窃听的问题——加密
1. 对称加密  
这种方式加密和解密同用一个密钥。加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了  
以对称加密方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落人攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥

2. 非对称加密
使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。  
缺点:
* 公钥并不包含服务器的信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，服务器发送给客户端的公钥可能在传送过程中被中间人截获并篡改；
* 使用非对称加密在数据加密解密过程需要消耗一定时间，降低了数据传输效率；

3. 对称加密+非对称加密(HTTPS采用这种方式)
使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。就比如说你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，**在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式**。  
具体做法:发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。所以，HTTPS采用对称加密和非对称加密两者并用的混合加密机制，但是首先要将B的公钥给A,这个过程没有保障中间人可以拦截，所以要确认B给A的公钥是真的：**数字证书**

### 2.解决报文可能遭篡改问题——数字签名

数字签名有两种功效：
* 能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。
* 数字签名能确定消息的完整性,证明数据是否未被篡改过。
![](https://resource.limeili.co/image/202007042336.png)
将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者。接下来就是接收者校验数字签名的流程了
![](https://resource.limeili.co/image/202007042337.png)  

接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。当然，这个过程的前提是B知道A的公钥，问题的关键的是，和消息本身一样，公钥不能在不安全的网络中直接发送给A,或者说拿到的公钥如何证明是B的。此时就需要引入了证书颁发机构（Certificate Authority，简称CA），CA数量并不多，B客户端内置了所有受信任CA的证书。CA对A的公钥（和其他信息）数字签名后生成证书。

### 3.解决通信方身份可能被伪装的问题——数字证书
* 服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;
* CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;
* 如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个`签名`。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名;
* 客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;
* 客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。
* 客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。

![](https://resource.limeili.co/image/20200705134004.png)
![]()

## HTTPS工作流程
1. ClientHello  

首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。  

在这一步，客户端主要向服务器发送以下信息：

+ 客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。

+ 客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。

+ 客户端支持的密码套件列表，如 RSA 加密算法。

2. SeverHello  

服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：  
+ 确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。

+ 服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。

+ 确认的密码套件列表，如 RSA 加密算法。

+ 服务器的数字证书。

3. 客户端回应

客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。  

如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：

+ 一个随机数（pre-master key）。该随机数会被服务器公钥加密。

+ 加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。

+ 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。  

上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。

4. 服务器的最后回应

服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：

+ 加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。

+ 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。

## HTTP与HTTPS的区别
* HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全
* HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;
* HTTPS需要用到SSL证书，而HTTP不用;
* HTTPS标准端口443，HTTP标准端口80;
* HTTPS基于传输层，HTTP基于应用层;  SSL位于应用层之下 传输层之上
* HTTPS在浏览器显示绿色安全锁，HTTP没有显示;

